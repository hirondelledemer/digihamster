"use strict";(self.webpackChunkdigihamster=self.webpackChunkdigihamster||[]).push([[5281],{"./src/app/components/TaskInfo/TaskInfo.stories.tsx":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{__webpack_require__.r(__webpack_exports__),__webpack_require__.d(__webpack_exports__,{Default:()=>Default,__namedExportsOrder:()=>__namedExportsOrder,default:()=>TaskInfo_stories});var jsx_runtime=__webpack_require__("./node_modules/next/dist/compiled/react/jsx-runtime.js"),react=__webpack_require__("./node_modules/next/dist/compiled/react/index.js"),sheet=__webpack_require__("./src/app/components/ui/sheet.tsx"),utils=__webpack_require__("./src/app/components/utils/index.ts"),use_tasks=__webpack_require__("./src/app/utils/hooks/use-tasks.tsx"),TaskCard=__webpack_require__("./src/app/components/TaskCard/index.ts"),CreateTaskForm=__webpack_require__("./src/app/components/CreateTaskForm/index.ts"),dist=__webpack_require__("./node_modules/@radix-ui/react-scroll-area/dist/index.mjs");const ScrollArea=react.forwardRef((({className,children,...props},ref)=>(0,jsx_runtime.jsxs)(dist.bL,{ref,className:(0,utils.cn)("relative overflow-hidden",className),...props,children:[(0,jsx_runtime.jsx)(dist.LM,{className:"h-full w-full rounded-[inherit]",children}),(0,jsx_runtime.jsx)(ScrollBar,{}),(0,jsx_runtime.jsx)(dist.OK,{})]})));ScrollArea.displayName=dist.bL.displayName;const ScrollBar=react.forwardRef((({className,orientation="vertical",...props},ref)=>(0,jsx_runtime.jsx)(dist.VM,{ref,orientation,className:(0,utils.cn)("flex touch-none select-none transition-colors","vertical"===orientation&&"h-full w-2.5 border-l border-l-transparent p-[1px]","horizontal"===orientation&&"h-2.5 flex-col border-t border-t-transparent p-[1px]",className),...props,children:(0,jsx_runtime.jsx)(dist.lr,{className:"relative flex-1 rounded-full bg-border"})})));ScrollBar.displayName=dist.VM.displayName,ScrollArea.__docgenInfo={description:"",methods:[]},ScrollBar.__docgenInfo={description:"",methods:[],props:{orientation:{defaultValue:{value:'"vertical"',computed:!1},required:!1}}};var state_context=__webpack_require__("./src/app/utils/hooks/use-projects/state-context.ts"),MinimalNote=__webpack_require__("./src/app/components/MinimalNote/index.ts");const DEFAULT_NOTES_STATE={data:[],isLoading:!1,errorMessage:void 0},NotesStateContext=(0,react.createContext)(DEFAULT_NOTES_STATE);var test_dist=__webpack_require__("./node_modules/@storybook/test/dist/index.mjs"),navigation=__webpack_require__("./node_modules/@storybook/nextjs/dist/export-mocks/navigation/index.mjs");const useRouter=(0,test_dist.fn)(navigation.useRouter).mockName("useRouter"),useSearchParams=(0,test_dist.fn)(navigation.useSearchParams).mockName("useSearchParams"),TaskInfo=()=>{const searchParams=useSearchParams(),router=useRouter(),taskId=searchParams.get("taskId"),projectId=searchParams.get("projectId"),{data:tasks}=(0,use_tasks.Ay)(),{data:notes}=(0,react.useContext)(NotesStateContext),{getProjectById,isLoading}=(0,state_context.h)(),selectedTask=tasks.find((t=>t._id===taskId)),selectedProject=projectId&&!isLoading?getProjectById(projectId):null;if(!selectedTask&&!selectedProject)return null;const title=selectedTask?selectedTask.title:null==selectedProject?void 0:selectedProject.title,tasksToShow=selectedTask?tasks.filter((t=>selectedTask.relatedTaskIds.includes(t._id))):tasks.filter((t=>t.projectId===projectId)),notesToShow=selectedTask?notes.filter((n=>selectedTask.relatedNoteIds.includes(n._id))):[];return(0,jsx_runtime.jsx)(sheet.cj,{open:!0,children:(0,jsx_runtime.jsxs)(sheet.h,{side:"right","aria-describedby":"Task info",onCloseClick:()=>router.replace("/",void 0),showOverlay:!1,onEscapeKeyDown:()=>router.replace("/",void 0),children:[(0,jsx_runtime.jsx)(sheet.Fm,{children:(0,jsx_runtime.jsx)(sheet.qp,{children:title})}),(0,jsx_runtime.jsx)(ScrollArea,{className:"h-3/4 mb-2 mt-4",children:(0,jsx_runtime.jsxs)("div",{className:(0,utils.cn)(["flex flex-col gap-2"]),children:[selectedProject&&(0,jsx_runtime.jsx)("div",{className:"w-[300px]",children:(0,jsx_runtime.jsx)(MinimalNote.A,{note:selectedProject.jsonDescription})}),notesToShow.map((n=>(0,jsx_runtime.jsx)("div",{className:"w-[300px]",children:(0,jsx_runtime.jsx)(MinimalNote.A,{note:n.jsonNote})},n._id))),tasksToShow.map((rTask=>(0,jsx_runtime.jsx)(TaskCard.A,{task:rTask,dragId:rTask._id,indicateActive:!0},rTask._id)))]})}),(0,jsx_runtime.jsx)(CreateTaskForm.A,{onDone:()=>{},primaryTaskId:null==selectedTask?void 0:selectedTask._id,projectId:selectedTask?selectedTask.projectId||void 0:selectedProject?selectedProject._id:void 0})]})})},TaskInfo_TaskInfo=TaskInfo;TaskInfo.__docgenInfo={description:"",methods:[],displayName:"TaskInfo",props:{testId:{required:!1,tsType:{name:"string"},description:""}}};var task=__webpack_require__("./src/app/utils/mocks/task.ts");const generateNote=(i=1,properties)=>({_id:`note${i}`,title:`Note ${i}`,note:`note ${i}`,jsonNote:{content:[{content:[{text:`note ${i}`,type:"text"}],type:"paragraph"}],type:"doc"},isActive:!1,deleted:!1,userId:"",tags:[],updatedAt:"",...properties}),TaskInfo_stories={title:"Tasks/TaskInfo",component:TaskInfo_TaskInfo,tags:["autodocs"],decorators:[Story=>{return(0,jsx_runtime.jsx)(NotesStateContext.Provider,{value:{data:(noteInfo=[{_id:"note1"},{_id:"note1"}],noteInfo.map(((taskProperties,i)=>({...generateNote(i,taskProperties)})))),isLoading:!1},children:(0,jsx_runtime.jsx)(use_tasks.sF.Provider,{value:{data:(0,task.J_)([{_id:"task0",relatedTaskIds:["task1","task2"],relatedNoteIds:["note0","note1"]},{_id:"task1"},{_id:"task2"}]),loading:!1,setData:()=>{}},children:(0,jsx_runtime.jsx)(Story,{})})});var noteInfo}]},Default={async beforeEach(){useRouter.mockReturnValue({push:()=>{},replace:()=>{},back:()=>{},forward:()=>{},refresh:()=>{},prefetch:()=>{}}),useSearchParams.mockReturnValue({get:()=>"task0"})},args:{}},__namedExportsOrder=["Default"];Default.parameters={...Default.parameters,docs:{...Default.parameters?.docs,source:{originalSource:'{\n  async beforeEach() {\n    useRouter.mockReturnValue({\n      push: () => {},\n      replace: () => {},\n      back: () => {},\n      forward: () => {},\n      refresh: () => {},\n      prefetch: () => {}\n    });\n    useSearchParams.mockReturnValue({\n      get: () => "task0"\n    } as unknown as ReadonlyURLSearchParams);\n  },\n  args: defaultArgs\n}',...Default.parameters?.docs?.source}}}},"./src/app/components/MinimalNote/index.ts":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{__webpack_require__.d(__webpack_exports__,{A:()=>MinimalNote_MinimalNote});var jsx_runtime=__webpack_require__("./node_modules/next/dist/compiled/react/jsx-runtime.js"),react=__webpack_require__("./node_modules/next/dist/compiled/react/index.js"),RichTextEditor=__webpack_require__("./src/app/components/RichTextEditor/index.ts"),rte_hook=__webpack_require__("./src/app/utils/rte/rte-hook.ts"),use_toast=__webpack_require__("./src/app/components/ui/use-toast.ts");function isEditable(restProps){return restProps.editable}const MinimalNote=({testId,note,...restProps})=>{const editable=!!isEditable(restProps)&&restProps.editable,forForm=!!isEditable(restProps)&&restProps.forForm,{toast}=(0,use_toast.dj)(),{editor}=(0,rte_hook.P)({value:note,editable});if((0,react.useEffect)((()=>{null==editor||editor.setEditable(editable),editable&&!forForm&&(null==editor||editor.commands.focus("end"))}),[editor,editable,forForm]),!editor)return null;return(0,jsx_runtime.jsx)(RichTextEditor.A,{testId,editor,onKeyDown:event=>{editor||toast({title:"Error",description:"Cannot submit the note: Editor not found"}),"Enter"===event.key&&event.ctrlKey&&isEditable(restProps)&&(restProps.onSubmit(null==editor?void 0:editor.getHTML()),toast({title:"Success",description:"Note submitted"}))}})},MinimalNote_MinimalNote=MinimalNote;MinimalNote.__docgenInfo={description:"",methods:[],displayName:"MinimalNote"}}}]);